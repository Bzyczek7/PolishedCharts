import { useState, useEffect, useRef, useCallback, useMemo } from 'react'
import './App.css'
import Layout from './components/Layout'
import Toolbar, { type DataMode } from './components/Toolbar'
import Watchlist from './components/Watchlist'
import AlertsView from './components/AlertsView'
import ChartComponent from './components/ChartComponent'
import { OHLCDisplayWithTime } from './components/chart/OHLCDisplay'
import type { Alert } from './components/AlertsList'
import type { Layout as LayoutType } from './components/Toolbar'
import IndicatorPane from './components/IndicatorPane'
import { loadLayouts, saveLayouts, loadAlerts, saveAlerts } from './services/layoutService'
import { getCandles } from './api/candles'
import type { Candle } from './api/candles'
import { TooltipProvider } from '@/components/ui/tooltip'
import { Toaster, toast } from 'sonner'
import { formatDataForChart, formatIndicatorData } from './utils/chartHelpers'
import { IndicatorProvider, useIndicatorContext } from './contexts/IndicatorContext'
import { IndicatorDialog } from './components/indicators/IndicatorDialog'
import { ErrorBoundary } from './components/ErrorBoundary' // T049: Error boundary for indicator rendering
import { useIndicatorData } from './hooks/useIndicatorData'
import type { IndicatorOutput } from './components/types/indicators'
import type { Time, IRange } from 'lightweight-charts'
import { useWebSocket } from './hooks/useWebSocket'
import { CandleDataProvider } from './components/CandleDataProvider'
import { WatchlistDataProvider } from './components/WatchlistDataProvider'
import type { WatchlistItem } from './api/watchlist'
// Feature 009: Import watchlist API and search components
import { WatchlistSearch } from './components/WatchlistSearch'
import { useWatchlist } from './hooks/useWatchlist'
import { getWatchlist, addToWatchlist, removeFromWatchlist } from './api/watchlist'
// Feature 008: Overlay indicator instance management with styling
import { useIndicatorInstances } from './hooks/useIndicatorInstances'
import type { IndicatorInstance } from './components/types/indicators'
import { IndicatorSettingsDialog } from './components/IndicatorSettingsDialog'
import { OverlayIndicatorLegend } from './components/OverlayIndicatorLegend'
import { SourceCodeModal } from './components/SourceCodeModal'
// Phase 6: Oscillator settings dialog
import { OscillatorSettingsDialog } from './components/OscillatorSettingsDialog'

// Feature 008: Load manual test module (available in browser console for testing)
if (import.meta.env.DEV) {
  import('./tests/manual/feature008-manual-test')
}

interface AppContentProps {
  symbol: string
  setSymbol: (symbol: string) => void
}

function AppContent({ symbol, setSymbol }: AppContentProps) {
  const [chartInterval, setChartInterval] = useState('1d')
  const [dataMode, setDataMode] = useState<DataMode>('websocket') // T026: Data mode toggle state
  const [isSearchOpen, setIsSearchOpen] = useState(false)
  const [isIndicatorsOpen, setIsIndicatorsOpen] = useState(false)
  const mainViewportRef = useRef<HTMLDivElement>(null)
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })
  const [mainTimeScale, setMainTimeScale] = useState<any>(null)
  const indicatorTimeScalesRef = useRef<Map<string, any>>(new Map())
  const { connect, disconnect, lastMessage } = useWebSocket();

  // Feature 009: Use API-based watchlist hook instead of localStorage
  const {
    entries: apiWatchlistEntries,
    symbols: watchlistSymbols,
    isLoading: watchlistLoading,
    error: watchlistError,
    refetch: refetchWatchlist,
    addSymbol: addSymbolToWatchlist,
    removeSymbol: removeSymbolFromWatchlist,
    clearError: clearWatchlistError,
  } = useWatchlist()

  // Local state for visual ordering (drag-and-drop reordering)
  // The API doesn't support persistent ordering, so we keep it local only
  const [orderedSymbols, setOrderedSymbols] = useState<string[]>([])

  // Update ordered symbols when API watchlist changes
  useEffect(() => {
    setOrderedSymbols(prev => {
      // If local order is empty or very different, use API order
      if (prev.length === 0 || Math.abs(prev.length - watchlistSymbols.length) > 2) {
        return [...watchlistSymbols]
      }
      // Add new symbols to the end
      const newSymbols = watchlistSymbols.filter(s => !prev.includes(s))
      return [...prev, ...newSymbols]
    })
  }, [watchlistSymbols])

  // Memoize watchlist items for Watchlist component
  // Price data will be populated by WatchlistDataProvider
  const watchlist = useMemo(() => {
    return orderedSymbols.map(symbol => ({ symbol }))
  }, [orderedSymbols])

  const [alerts, setAlerts] = useState<Alert[]>(() => loadAlerts())
  const [layouts, setLayouts] = useState<LayoutType[]>([])
  const [activeLayout, setActiveLayout] = useState<LayoutType | null>(null)
  const [candles, setCandles] = useState<Candle[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [hasMoreHistory, setHasMoreHistory] = useState(true)
  const lastFetchedToDateRef = useRef<string | null>(null)
  const [visibleRange, setVisibleRange] = useState<IRange<Time> | null>(null)
  const [crosshairTime, setCrosshairTime] = useState<number | null>(null)
  const [crosshairCandle, setCrosshairCandle] = useState<Candle | null>(null)
  const [indicatorSettings, setIndicatorSettings] = useState<Record<string, { visible: boolean; series: Record<string, boolean>; showLevels: boolean; showLastValue: boolean }>>({})
  const [isInitialLoading, setIsInitialLoading] = useState(true) // T101: Initial loading state
  const [error, setError] = useState<string | null>(null) // T102: Error state
  const mainChartRef = useRef<any>(null)
  const indicatorChartsRef = useRef<Map<string, { chart: any; series: any }>>(new Map())
  // T072: Store the polling refresh function for manual refresh button
  const candleRefreshRef = useRef<(() => void) | null>(null)

  // Use the new indicator system
  const { indicators, addIndicator, removeIndicator, updateIndicatorStyle } = useIndicatorContext()
  const indicatorDataMap = useIndicatorData(indicators, symbol, chartInterval)

  // Feature 008 - T014: Integrate useIndicatorInstances for overlay indicator management
  const {
    instances: overlayInstances,
    isLoaded: overlayInstancesLoaded,
    addIndicator: addOverlayInstance,
    removeIndicator: removeOverlayInstance,
    updateStyle,
    toggleVisibility,
    updateInstance, // T047: Generic instance update for settings dialog
    isOffline: overlayOffline
  } = useIndicatorInstances(symbol)

  // T047: Settings dialog state for overlay indicators
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)
  const [settingsIndicatorId, setSettingsIndicatorId] = useState<string | null>(null)

  // Phase 6: Oscillator settings dialog state
  const [oscillatorSettingsOpen, setOscillatorSettingsOpen] = useState(false)
  const [oscillatorSettingsIndicatorId, setOscillatorSettingsIndicatorId] = useState<string | null>(null)

  // Feature 008: Source code modal state
  const [sourceCodeIndicatorId, setSourceCodeIndicatorId] = useState<string | null>(null)

  // Feature 008 - T015: Fetch data for overlay instances using useIndicatorData
  // Cast IndicatorInstance[] to IndicatorPane[] for compatibility (both have id and indicatorType)
  const overlayInstanceDataMap = useIndicatorData(overlayInstances as any, symbol, chartInterval)

  // Effect to automatically sync indicators with the active layout
  // - Adds new indicators from context to activeLayout.activeIndicators
  // - Removes indicators from activeLayout.activeIndicators that are no longer in context
  useEffect(() => {
    if (activeLayout) {
      // Get all indicator names from the context
      const contextIndicatorNames = indicators.map(ind => ind.indicatorType.name.toLowerCase());

      // Find indicators that are in the context but not in the active layout (to add)
      const missingFromActiveLayout = contextIndicatorNames.filter(name =>
        !activeLayout.activeIndicators.includes(name)
      );

      // Find indicators that are in the active layout but not in the context (to remove)
      const removedFromContext = activeLayout.activeIndicators.filter(name =>
        !contextIndicatorNames.includes(name)
      );

      // Update active layout if there are changes
      if (missingFromActiveLayout.length > 0 || removedFromContext.length > 0) {
        const updated: LayoutType = {
          ...activeLayout,
          activeIndicators: [
            ...activeLayout.activeIndicators.filter(name => !removedFromContext.includes(name)),
            ...missingFromActiveLayout
          ]
        };

        setActiveLayout(updated);

        if (activeLayout.id !== 'default') {
          const updatedLayouts = layouts.map(l => l.id === updated.id ? updated : l);
          setLayouts(updatedLayouts);
          saveLayouts(updatedLayouts);
        }
      }
    }
  }, [indicators, activeLayout, layouts]);

  const toggleIndicatorVisibility = useCallback((indicatorId: string) => {
    setIndicatorSettings(prev => ({
        ...prev,
        [indicatorId]: {
            ...prev[indicatorId],
            visible: prev[indicatorId]?.visible === false ? true : false
        }
    }))
  }, [])

  const toggleSeriesVisibility = useCallback((indicatorId: string, seriesId: string) => {
    setIndicatorSettings(prev => ({
        ...prev,
        [indicatorId]: {
            ...prev[indicatorId],
            series: {
                ...prev[indicatorId]?.series,
                [seriesId]: prev[indicatorId]?.series?.[seriesId] === false ? true : false
            }
        }
    }))
  }, [])

  const toggleLevelsVisibility = useCallback((indicatorId: string) => {
    setIndicatorSettings(prev => ({
        ...prev,
        [indicatorId]: {
            ...prev[indicatorId],
            showLevels: prev[indicatorId]?.showLevels === false ? true : false
        }
    }))
  }, [])

  const toggleLastValueVisibility = useCallback((indicatorId: string) => {
    setIndicatorSettings(prev => ({
      ...prev,
      [indicatorId]: {
        ...prev[indicatorId],
        showLastValue: !(prev[indicatorId]?.showLastValue ?? false)
      }
    }))
  }, [])

  useEffect(() => {
    if (!mainViewportRef.current) return

    const observer = new ResizeObserver((entries) => {
        if (entries[0]) {
            const { width, height } = entries[0].contentRect
            setDimensions({ width, height })
        }
    })

    observer.observe(mainViewportRef.current)
    return () => observer.disconnect()
  }, [])

  useEffect(() => {
    if (!mainTimeScale) return

    const handleRangeChange = (range: any) => {
        if (!range) return
        indicatorTimeScalesRef.current.forEach((ts) => {
            ts.setVisibleLogicalRange(range)
        })
    }

    mainTimeScale.subscribeVisibleLogicalRangeChange(handleRangeChange)
    
    const currentRange = mainTimeScale.getVisibleLogicalRange()
    if (currentRange) {
        indicatorTimeScalesRef.current.forEach((ts) => {
            ts.setVisibleLogicalRange(currentRange)
        })
    }

    return () => {
        mainTimeScale.unsubscribeVisibleLogicalRangeChange(handleRangeChange)
    }
  }, [mainTimeScale, activeLayout?.activeIndicators, candles])

  // Feature 009: Removed localStorage saveWatchlist - watchlist is now managed by API
  // useEffect(() => {
  //   saveWatchlist(watchlist.map(item => item.symbol))
  // }, [watchlist])

  useEffect(() => {
    saveAlerts(alerts)
  }, [alerts])

  useEffect(() => {
    // Connect to websocket for real-time updates only in WebSocket mode
    if (dataMode === 'websocket' && symbol && chartInterval) {
        const wsUrl = `ws://localhost:8000/api/v1/candles/ws/${symbol}?interval=${chartInterval}`;
        connect(wsUrl);
    } else {
        disconnect();
    }
    return () => {
        disconnect();
    };
  }, [symbol, chartInterval, connect, disconnect, dataMode]);

  useEffect(() => {
    // Skip WS updates until initial REST data has loaded (prevents visual flicker).
    // Also checks prevCandles.length inside setCandles to prevent processing messages when REST failed/returned empty.
    if (lastMessage && !isInitialLoading) {
      const newCandle = JSON.parse(lastMessage.data);
      setCandles(prevCandles => {
        // Skip processing if REST data hasn't loaded successfully (empty or failed)
        if (prevCandles.length === 0) {
          return prevCandles;
        }

        // Keep existing epoch-ms Map dedupe logic
        const uniqueCandlesMap = new Map();

        // Add all existing candles to the map (using timestamp as key)
        prevCandles.forEach(candle => {
          const timestampKey = new Date(candle.timestamp).getTime();
          uniqueCandlesMap.set(timestampKey, candle);
        });

        // Add or update the new candle
        const newCandleTimestamp = new Date(newCandle.timestamp).getTime();
        const existingCandle = uniqueCandlesMap.get(newCandleTimestamp);

        // Optional: Skip update if OHLC values are identical (prevents unnecessary re-renders)
        if (existingCandle &&
            existingCandle.open === newCandle.open &&
            existingCandle.high === newCandle.high &&
            existingCandle.low === newCandle.low &&
            existingCandle.close === newCandle.close &&
            existingCandle.volume === newCandle.volume) {
          return prevCandles; // No change, skip re-render
        }

        uniqueCandlesMap.set(newCandleTimestamp, newCandle);

        // Convert back to array and sort
        const updatedCandles = Array.from(uniqueCandlesMap.values());
        return updatedCandles.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      });
    }
  }, [lastMessage, isInitialLoading]);

  useEffect(() => {
    const down = (e: KeyboardEvent) => {
      // Cmd/Ctrl+K: Open search
      if (e.key === "k" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault()
        setIsSearchOpen((open) => !open)
      }
      // Cmd/Ctrl+I: Open indicators
      if (e.key === "i" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault()
        setIsIndicatorsOpen((open) => !open)
      }
      // T095, T096: Plus/Equals key to zoom in, Minus to zoom out
      if (e.key === "=" || e.key === "+") {
        e.preventDefault()
        // Zoom in by reducing visible range
        if (mainTimeScale) {
          const currentRange = mainTimeScale.getVisibleLogicalRange()
          if (currentRange) {
            const rangeWidth = currentRange.to - currentRange.from
            const newRangeWidth = rangeWidth * 0.8 // Zoom in by 20%
            const center = (currentRange.from + currentRange.to) / 2
            mainTimeScale.setVisibleLogicalRange({
              from: center - newRangeWidth / 2,
              to: center + newRangeWidth / 2
            })
          }
        }
      }
      if (e.key === "-" || e.key === "_") {
        e.preventDefault()
        // Zoom out by increasing visible range
        if (mainTimeScale) {
          const currentRange = mainTimeScale.getVisibleLogicalRange()
          if (currentRange) {
            const rangeWidth = currentRange.to - currentRange.from
            const newRangeWidth = rangeWidth * 1.2 // Zoom out by 20%
            const center = (currentRange.from + currentRange.to) / 2
            mainTimeScale.setVisibleLogicalRange({
              from: center - newRangeWidth / 2,
              to: center + newRangeWidth / 2
            })
          }
        }
      }
      // T097: 0 to reset zoom (R key removed)
      if ((e.key === "0" && !e.ctrlKey && !e.metaKey)) {
        e.preventDefault()
        if (mainTimeScale) {
          mainTimeScale.fitContent()
        }
      }
      // T098: Escape to exit drawing mode (if implemented)
      if (e.key === "Escape") {
        // This will be used when drawing tools are implemented
        // For now, just ensure no modal is open
        if (isSearchOpen) setIsSearchOpen(false)
        if (isIndicatorsOpen) setIsIndicatorsOpen(false)
      }
      // T099: C to toggle crosshair (handled by lightweight-charts natively)
      // The crosshair visibility is managed by lightweight-charts internal state
    }
    window.addEventListener("keydown", down)
    return () => window.removeEventListener("keydown", down)
  }, [mainTimeScale, isSearchOpen, isIndicatorsOpen])

  useEffect(() => {
    const saved = loadLayouts()
    setLayouts(saved)
    if (saved.length > 0) {
        setActiveLayout(saved[0])
    } else {
        const defaultLayout: LayoutType = {
            id: 'default',
            name: 'Default Layout',
            activeIndicators: [],
            indicatorParams: {}
        }
        setActiveLayout(defaultLayout)
    }
  }, [])

  useEffect(() => {
    // Reset pagination state when symbol or interval changes
    setHasMoreHistory(true)
    lastFetchedToDateRef.current = null
    setIsInitialLoading(true) // T101: Set loading state
    setError(null) // T102: Clear error state

    const fetchData = async () => {
        try {
            const to = new Date().toISOString()
            const fromDate = new Date()
            // Set lookback based on interval (must match API MAX_RANGE_DAYS in candles.py)
            const daysBackMap: Record<string, number> = {
                '1m': 1, '2m': 2, '5m': 30, '15m': 30,
                '30m': 60, '1h': 60, '4h': 120,
                '1d': 730, '1wk': 1460
            }
            const daysBack = daysBackMap[chartInterval] || 60
            fromDate.setDate(fromDate.getDate() - daysBack)
            const from = fromDate.toISOString()

            // Only fetch candles - indicator data is fetched by useIndicatorData hook
            const candleData = await getCandles(symbol, chartInterval, from, to).catch(() => [])
            setCandles(candleData)

            // T102: Check if we got valid data
            if (candleData.length === 0) {
                setError(`No data available for ${symbol}`)
            }
        } catch (e) {
            console.error('Failed to fetch data', e)
            // T102: Set error state
            setError(`Failed to load data for ${symbol}. Please try again.`)
        } finally {
            setIsInitialLoading(false) // T101: Clear loading state
        }
    }
    fetchData()
  }, [symbol, chartInterval])

  // Feature 009: Simplified handleSymbolSelect - just changes the active symbol
  // Adding to watchlist is now done via WatchlistSearch component
  const handleSymbolSelect = useCallback((newSymbol: string) => {
    setSymbol(newSymbol)
    // Note: No longer automatically adds to watchlist - user must explicitly add via search
  }, [])

  const handleLayoutSave = useCallback((name: string) => {
    const newLayout: LayoutType = {
        id: Date.now().toString(),
        name,
        activeIndicators: activeLayout?.activeIndicators || [],
        indicatorParams: activeLayout?.indicatorParams || {}
    }
    const updated = [...layouts, newLayout]
    setLayouts(updated)
    saveLayouts(updated)
    setActiveLayout(newLayout)
  }, [activeLayout, layouts])

  const toggleIndicator = useCallback((indicator: string) => {
    const currentLayout = activeLayout || {
        id: 'default',
        name: 'Default Layout',
        activeIndicators: [],
        indicatorParams: {}
    }
    
    const active = currentLayout.activeIndicators.includes(indicator)
    const updated: LayoutType = {
        ...currentLayout,
        activeIndicators: active 
            ? currentLayout.activeIndicators.filter((i: string) => i !== indicator)
            : [...currentLayout.activeIndicators, indicator]
    }
    
    setActiveLayout(updated)
    
    if (updated.id !== 'default') {
        const updatedLayouts = layouts.map(l => l.id === updated.id ? updated : l)
        setLayouts(updatedLayouts)
        saveLayouts(updatedLayouts)
    }
  }, [activeLayout, layouts])

  const triggeredCount = alerts.filter(a => a.status === 'triggered').length

  const toggleFullscreen = useCallback(() => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message}`);
        });
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
  }, [])

  // T026: Toggle between WebSocket and polling modes
  const handleDataModeToggle = useCallback(() => {
    setDataMode(prev => prev === 'websocket' ? 'polling' : 'websocket')
  }, [])

  // T072: Handle manual refresh button click
  const handleManualRefresh = useCallback(() => {
    if (dataMode === 'polling' && candleRefreshRef.current) {
      candleRefreshRef.current()
    }
  }, [dataMode])

  // Feature 009: Watchlist handlers using API
  const handleWatchlistRemove = useCallback(async (symbols: string[]) => {
    // Remove each symbol from the API
    for (const symbol of symbols) {
      try {
        await removeSymbolFromWatchlist(symbol)
        toast.success(`Removed ${symbol} from watchlist`)
      } catch (error) {
        console.error('Failed to remove symbol:', error)
        toast.error(`Failed to remove ${symbol}`)
      }
    }
  }, [removeSymbolFromWatchlist])

  // Handle watchlist reordering (local state only, not persisted to API)
  const handleWatchlistReorder = useCallback((items: WatchlistItem[]) => {
    setOrderedSymbols(items.map(item => item.symbol))
  }, [])

  // Feature 009: Handler for search dialog - only changes chart symbol
  const handleSearchSelectSymbol = useCallback((selectedSymbol: string) => {
    setSymbol(selectedSymbol)
  }, [setSymbol])

  // Separate overlay indicators from pane indicators
  const overlayIndicators = useMemo(() => {
    return indicators.filter(ind => ind.indicatorType.category === 'overlay')
  }, [indicators])

  const paneIndicators = useMemo(() => {
    return indicators.filter(ind => ind.indicatorType.category === 'oscillator')
  }, [indicators])

  // Feature 005: Ratio-based pane height allocation (TradingView-like behavior)
  // Compute visible oscillator panes using same visibility check as rendering
  const visibleOscillators = useMemo(() => {
    return paneIndicators.filter(ind => {
      const data = indicatorDataMap[ind.id]
      return data && ind.displaySettings.visible && indicatorSettings[ind.id]?.visible !== false
    })
  }, [paneIndicators, indicatorDataMap, indicatorSettings])

  // Ratio-based allocation: mainWeight=3, each pane gets paneWeight=1
  // This guarantees: N=0 → main=100%, N increases → all panes shrink smoothly
  const MAIN_WEIGHT = 3
  const PANE_WEIGHT = 1
  const MIN_PANE_HEIGHT = 100  // Minimum height for oscillator panels to ensure visibility

  const availableHeight = Math.max(dimensions.height - 40, 300)  // Subtract padding
  const maxPossiblePanes = Math.floor(availableHeight / MIN_PANE_HEIGHT)
  const effectiveVisibleOscillators = visibleOscillators.slice(0, maxPossiblePanes)

  const totalWeight = MAIN_WEIGHT + (effectiveVisibleOscillators.length * PANE_WEIGHT)

  const mainHeight = effectiveVisibleOscillators.length === 0
    ? availableHeight
    : availableHeight * (MAIN_WEIGHT / totalWeight)

  const eachPaneHeight = effectiveVisibleOscillators.length > 0
    ? Math.max(availableHeight * (PANE_WEIGHT / totalWeight), MIN_PANE_HEIGHT)
    : 0

  // Format overlay indicators for ChartComponent
  const overlays = useMemo(() => {
    const formattedOverlays: Array<{ id: string; data: { time: number; value: number; color?: string }[]; color: string; lineWidth: number; showLastValue?: boolean }> = [];

    overlayIndicators
      .filter(ind => indicatorSettings[ind.id]?.visible !== false)
      .forEach(ind => {
        const data = indicatorDataMap[ind.id]
        if (!data) return;

        const mainSeries = data.metadata.series_metadata[0]
        if (!mainSeries) return;

        const seriesData = data.data[mainSeries.field]
        if (!seriesData) return;

        // Keep timestamps as numbers - they're already Unix seconds from the backend
        const timestamps = data.timestamps

        // Check if indicator has a signal series for coloring (e.g., ADXVMA_Signal)
        const signalSeries = data.metadata.series_metadata.find(s => s.role === 'signal')
        const signalData = signalSeries ? data.data[signalSeries.field] : null

        if (signalData) {
          // One series, per-point color (TradingView-like)
          const coloredData = timestamps
            .map((t, i) => {
              const value = seriesData[i]
              const signal = signalData[i]

              if (value === null || value === undefined) return null

              const time = t // keep numeric, no toUnixSeconds conversion needed since timestamps are already numeric
              const color =
                signal === 1 ? '#00FF00' :
                signal === 0 ? '#FFFF00' :
                signal === -1 ? '#ef5350' :
                mainSeries.line_color

              return { time, value: value as number, color }
            })
            .filter((p): p is { time: number; value: number; color: string } => p !== null)

          const typeKey = ind.indicatorType.name.toLowerCase()
          const showLastValue =
            indicatorSettings[ind.id]?.showLastValue ??
            indicatorSettings[typeKey]?.showLastValue ??
            true
          formattedOverlays.push({
            id: ind.id,
            data: coloredData,
            color: mainSeries.line_color,     // series default; per-point overrides it
            lineWidth: mainSeries.line_width,
            showLastValue,
          })
        } else {
          // existing non-signal path
          const formattedData = formatDataForChart(timestamps, seriesData)
          const typeKey = ind.indicatorType.name.toLowerCase()
          const showLastValue =
            indicatorSettings[ind.id]?.showLastValue ??
            indicatorSettings[typeKey]?.showLastValue ??
            true
          formattedOverlays.push({
            id: ind.id,
            data: formattedData,
            color: mainSeries.line_color,
            lineWidth: mainSeries.line_width,
            showLastValue,
          })
        }
      })

    return formattedOverlays
  }, [overlayIndicators, indicatorDataMap, indicatorSettings])

  // Feature 008 - T015: Format overlay instances with per-instance styling
  const feature008Overlays = useMemo(() => {
    const formattedOverlays: Array<{
      id: string;
      data: { time: number; value: number; color?: string }[];
      color: string;
      lineWidth: number;
      showLastValue?: boolean;
      visible?: boolean; // T013: Support visibility option
    }> = [];

    overlayInstances
      .filter(instance => instance.isVisible) // T013: Respect isVisible from instance
      .forEach(instance => {
        const data = overlayInstanceDataMap[instance.id];
        if (!data) return;

        // Use formatIndicatorData helper from chartHelpers (T012)
        // Pass instance.seriesColors for trend-based color overrides (bullish/neutral/bearish)
        const formattedData = formatIndicatorData(data, undefined, instance.style.seriesColors);

        // Apply instance styling
        formattedOverlays.push({
          id: instance.id,
          data: formattedData,
          color: instance.style.color,
          lineWidth: instance.style.lineWidth,
          showLastValue: instance.style.showLastValue,
          visible: instance.isVisible, // T013: Pass visibility to ChartComponent
        });
      });

    return formattedOverlays;
  }, [overlayInstances, overlayInstanceDataMap]);

  // Feature 008 - T015: Merge existing overlays with Feature 008 overlays
  // Priority: Feature 008 overlays (with per-instance styling) take precedence over existing overlays
  const mergedOverlays = useMemo(() => {
    const existingOverlayIds = new Set(overlays.map(o => o.id));
    const merged = [...overlays];

    // Add or replace with Feature 008 overlays
    feature008Overlays.forEach(feature008Overlay => {
      const existingIndex = merged.findIndex(o => o.id === feature008Overlay.id);
      if (existingIndex >= 0) {
        // Replace with Feature 008 overlay (has styling priority)
        merged[existingIndex] = feature008Overlay;
      } else {
        // Add new Feature 008 overlay
        merged.push(feature008Overlay);
      }
    });

    return merged;
  }, [overlays, feature008Overlays]);

  // Phase 0: Create series data map for overlay legend crosshair values
  // Maps instance ID to formatted data points {time, value}
  const overlaySeriesDataMap = useMemo(() => {
    const map: Record<string, { time: number; value: number }[]> = {};
    feature008Overlays.forEach(overlay => {
      map[overlay.id] = overlay.data;
    });
    return map;
  }, [feature008Overlays]);

  // Main crosshair move handler
  const handleMainCrosshairMove = useCallback((param: any) => {
    // ignore non-pointer / programmatic moves to avoid jitter during scroll
    if (!param?.sourceEvent) return

    const t = param?.time
    if (!t) {
      indicatorChartsRef.current.forEach(({ chart }) => {
        try {
          chart.clearCrosshairPosition?.()
        } catch(e) {}
      })
      setCrosshairCandle(null)
      return
    }

    setCrosshairTime(t)

    // Find the candle at the crosshair time for OHLCDisplay
    const matchedCandle = candles.find(c => {
      const candleTime = Math.floor(new Date(c.timestamp).getTime() / 1000)
      return candleTime === t
    })
    setCrosshairCandle(matchedCandle || null)

    // Sync crosshair to all dynamic indicator panes
    paneIndicators.forEach(ind => {
      const entry = indicatorChartsRef.current.get(ind.id)
      if (!entry) return

      const data = indicatorDataMap[ind.id]
      if (!data) return

      // Find the value at the crosshair time
      const firstSeries = data.metadata.series_metadata[0]
      if (!firstSeries) return

      const seriesData = data.data[firstSeries.field]
      if (!seriesData) return

      // Find the value at the timestamp
      const timestampIndex = data.timestamps.indexOf(t as unknown as number)
      if (timestampIndex === -1) return

      const v = seriesData[timestampIndex]
      if (v !== null && v !== undefined) {
        entry.chart.setCrosshairPosition(v, t, entry.series)
      } else {
        entry.chart.clearCrosshairPosition?.()
      }
    })
  }, [paneIndicators, indicatorDataMap, candles])

  const handleIntervalSelect = useCallback((newInterval: string) => {
    setChartInterval(newInterval.toLowerCase())
  }, [])

  // Phase 6: Oscillator context menu handlers
  const handleOscillatorSettings = useCallback((indicatorId: string) => {
    setOscillatorSettingsIndicatorId(indicatorId)
    setOscillatorSettingsOpen(true)
  }, [])

  const handleOscillatorRemove = useCallback((indicatorId: string) => {
    removeIndicator(indicatorId)
  }, [removeIndicator])

  const handleOscillatorApplyChanges = useCallback((indicatorId: string, style: Partial<import('./components/types/indicators').IndicatorStyle>) => {
    if (updateIndicatorStyle) {
      updateIndicatorStyle(indicatorId, style)
    }
  }, [updateIndicatorStyle])

  const handleOscillatorViewSource = useCallback((indicatorId: string) => {
    setSourceCodeIndicatorId(indicatorId)
  }, [])

  // Ref to avoid circular dependency in handleVisibleTimeRangeChange
  const fetchMoreHistoryRef = useRef<any>(null)

  const fetchMoreHistory = useCallback(async () => {
    if (isLoading || !hasMoreHistory || candles.length === 0) return
    
    const earliestDateStr = candles[0].timestamp
    if (lastFetchedToDateRef.current === earliestDateStr) return
    lastFetchedToDateRef.current = earliestDateStr

    setIsLoading(true)
    try {
        const earliestDate = new Date(earliestDateStr)
        const to = earliestDate.toISOString()
        
        const fromDate = new Date(earliestDate)
        // Set chunk size based on interval (must match API MAX_RANGE_DAYS in candles.py)
        const daysBackMap: Record<string, number> = {
            '1m': 1, '2m': 2, '5m': 30, '15m': 30,
            '30m': 60, '1h': 60, '4h': 120,
            '1d': 730, '1wk': 1460
        }
        const daysBack = daysBackMap[chartInterval] || 60
        fromDate.setDate(fromDate.getDate() - daysBack)
        const from = fromDate.toISOString()

        const moreCandles = await getCandles(symbol, chartInterval, from, to)

        if (moreCandles.length > 0) {
            setCandles(prev => {
                const combined = [...moreCandles, ...prev]
                const unique = combined.filter((c, index, self) =>
                    index === self.findIndex((t) => t.timestamp === c.timestamp)
                )
                return unique.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())
            })
            // Note: Indicators are automatically refreshed by useIndicatorData when symbol/interval changes
        } else {
            setHasMoreHistory(false)
        }
    } catch (e) {
        console.error('Failed to fetch more history', e)
    } finally {
        setIsLoading(false)
    }
  }, [isLoading, hasMoreHistory, candles, symbol, chartInterval])

  // Keep ref updated
  useEffect(() => {
    fetchMoreHistoryRef.current = fetchMoreHistory
  }, [fetchMoreHistory])

  const handleVisibleTimeRangeChange = useCallback((range: IRange<Time> | null) => {
    if (!range) return
    setVisibleRange(range)
    
    if (candles.length > 0 && !isLoading && hasMoreHistory) {
        const earliestLoaded = Math.floor(new Date(candles[0].timestamp).getTime() / 1000)
        // Trigger when within 20% of the currently loaded data's start
        const latestLoaded = Math.floor(new Date(candles[candles.length-1].timestamp).getTime() / 1000)
        const loadedDuration = latestLoaded - earliestLoaded
        const threshold = earliestLoaded + (loadedDuration * 0.2)
        
        if (Number(range.from) <= threshold) {
            fetchMoreHistoryRef.current?.()
        }
    }
  }, [candles, isLoading, hasMoreHistory])

  return (
    <>
      <Toaster />
      <TooltipProvider>
          <Layout
            alertsBadgeCount={triggeredCount}
            watchlistContent={
                <WatchlistDataProvider symbols={orderedSymbols}>
                    {(watchlistState) => (
                        <Watchlist
                            items={watchlistState.entries.length > 0 ? watchlistState.entries : watchlist}
                            onAddClick={() => setIsSearchOpen(true)}
                            onRemove={handleWatchlistRemove}
                            onSelect={handleSymbolSelect}
                            onReorder={handleWatchlistReorder}
                            isRefreshing={watchlistState.isRefreshing}
                            lastUpdate={watchlistState.lastUpdate}
                        />
                    )}
                </WatchlistDataProvider>
            }
            alertsContent={
                <AlertsView
                    alerts={alerts}
                    symbol={symbol}
                    onToggleMute={async (id) => {
                        const alert = alerts.find(a => a.id === id)
                        if (!alert) return
                        try {
                            const { muteAlert, unmuteAlert } = await import('./api/alerts')
                            if (alert.status === 'muted') {
                                await unmuteAlert(Number(id))
                                setAlerts(prev => prev.map(a => a.id === id ? { ...a, status: 'active' as const } : a))
                                toast.success('Alert unmuted')
                            } else {
                                await muteAlert(Number(id))
                                setAlerts(prev => prev.map(a => a.id === id ? { ...a, status: 'muted' as const } : a))
                                toast.success('Alert muted')
                            }
                        } catch (error) {
                            console.error('Failed to toggle mute:', error)
                            toast.error('Failed to toggle mute')
                        }
                    }}
                    onDelete={async (id) => {
                        try {
                            const { deleteAlert } = await import('./api/alerts')
                            await deleteAlert(Number(id))
                            setAlerts(prev => prev.filter(a => a.id !== id))
                            toast.success('Alert deleted')
                        } catch (error) {
                            console.error('Failed to delete alert:', error)
                            toast.error('Failed to delete alert')
                        }
                    }}
                    onSelect={setSymbol}
                    onTriggerDemo={(id) => setAlerts(prev => prev.map(a => a.id === id ? { ...a, status: 'triggered' } : a))}
                    onAlertCreated={(newAlert) => setAlerts(prev => [...prev, newAlert])}
                />
            }
        >
            <div ref={mainViewportRef} data-testid="main-viewport" className="flex flex-col h-full w-full p-0 space-y-0">

                <Toolbar
                    symbol={symbol}
                    interval={chartInterval}
                    onIntervalSelect={handleIntervalSelect}
                    onSymbolClick={() => setIsSearchOpen(true)}
                    onIndicatorsClick={() => setIsIndicatorsOpen(true)}
                    onFullscreenToggle={toggleFullscreen}
                    activeLayout={activeLayout}
                    savedLayouts={layouts}
                    onLayoutSelect={setActiveLayout}
                    onLayoutSave={handleLayoutSave}
                    indicatorSettings={indicatorSettings}
                    indicators={indicators}
                    onToggleIndicatorVisibility={toggleIndicatorVisibility}
                    onToggleSeriesVisibility={toggleSeriesVisibility}
                    onToggleLevelsVisibility={toggleLevelsVisibility}
                    onToggleLastValueVisibility={toggleLastValueVisibility}
                    onRemoveIndicator={(indicatorIdOrName) => {
                        // indicatorIdOrName can be either:
                        // 1. A unique pane ID like "indicator-1234567890-abc123"
                        // 2. A type name like "sma" (from activeLayout.activeIndicators)

                        // First, try to find an indicator with matching ID
                        const matchingById = indicators.find(ind => ind.id === indicatorIdOrName);

                        if (matchingById) {
                            // It's a unique ID, remove directly
                            removeIndicator(indicatorIdOrName);
                            return;
                        }

                        // It's a type name, find the first indicator with matching type (case-insensitive)
                        const matchingByType = indicators.find(ind =>
                            ind.indicatorType.name.toLowerCase() === indicatorIdOrName.toLowerCase()
                        );

                        if (matchingByType) {
                            removeIndicator(matchingByType.id);
                        } else {
                            console.warn(`Could not find indicator to remove: ${indicatorIdOrName}`);
                        }
                    }}
                    dataMode={dataMode}
                    onDataModeToggle={handleDataModeToggle}
                    onManualRefresh={handleManualRefresh}
                />

                <div className="flex-1 flex flex-col min-h-0 overflow-hidden">
                        <div className="bg-[#131722] px-2 py-1 flex items-center justify-between">
                            <OHLCDisplayWithTime candle={crosshairCandle} interval={chartInterval} />
                        </div>

                        <div style={{ height: mainHeight }} className="shrink-0 bg-slate-900 border-b-0 border-slate-800 relative min-h-0 overflow-hidden w-full">

                        {/* Feature 008: Overlay indicator legend - minimal style matching IndicatorPane */}
                        {overlayInstances.length > 0 && (
                          <div className="absolute left-2 top-1 z-10 flex gap-2 text-xs pointer-events-none">
                            <OverlayIndicatorLegend
                              instances={overlayInstances}
                              onToggleVisibility={(instanceId) => toggleVisibility(instanceId)}
                              onRemove={(instanceId) => removeOverlayInstance(instanceId)}
                              onSettings={(instanceId) => {
                                setSettingsIndicatorId(instanceId)
                                setIsSettingsOpen(true)
                              }}
                              onViewSource={(instanceId) => setSourceCodeIndicatorId(instanceId)}
                              onAlertCreated={async () => {
                                // Refresh alerts from backend after creating a new alert
                                try {
                                  const { listAlerts } = await import('./api/alerts');
                                  const updatedAlerts = await listAlerts({ symbol });
                                  setAlerts(updatedAlerts);
                                } catch (error) {
                                  console.error('Failed to refresh alerts:', error);
                                }
                              }}
                              symbol={symbol}
                              crosshairTime={crosshairTime}
                              seriesDataMap={overlaySeriesDataMap}
                            />
                          </div>
                        )}
                            {/* T026: Conditional rendering based on data mode */}
                            {dataMode === 'polling' ? (
                                /* Polling mode: Use CandleDataProvider wrapper */
                                <CandleDataProvider symbol={symbol} interval={chartInterval}>
                                    {(candleState) => {
                                        // T072: Store the refresh function for manual refresh button
                                        candleRefreshRef.current = candleState.refresh

                                        return (
                                        <>
                                            {/* T027: Loading indicator display */}
                                            {candleState.isLoading && (
                                                <div className="absolute inset-0 flex items-center justify-center bg-slate-900 z-10">
                                                    <div className="flex flex-col items-center gap-3">
                                                        <div className="animate-spin rounded-full h-8 w-8 border-2 border-blue-500 border-t-transparent"></div>
                                                        <span className="text-slate-400 text-sm">Loading chart data...</span>
                                                    </div>
                                                </div>
                                            )}
                                            {/* T037: Visual refresh indicator during background updates */}
                                            {candleState.isRefreshing && !candleState.isLoading && (
                                                <div className="absolute top-2 right-2 z-10">
                                                    <div className="flex items-center gap-2 bg-slate-800 px-2 py-1 rounded">
                                                        <div className="animate-spin rounded-full h-3 w-3 border border-blue-400 border-t-transparent"></div>
                                                        <span className="text-xs text-slate-400">Updating...</span>
                                                        {/* T029: Last update timestamp display */}
                                                        {candleState.lastUpdate && (
                                                            <span className="text-xs text-slate-500">
                                                                {candleState.lastUpdate.toLocaleTimeString()}
                                                            </span>
                                                        )}
                                                    </div>
                                                </div>
                                            )}
                                            {/* T029: Last update timestamp display (when not refreshing) */}
                                            {!candleState.isRefreshing && !candleState.isLoading && candleState.lastUpdate && (
                                                <div className="absolute top-2 right-2 z-10">
                                                    <span className="text-xs text-slate-500 bg-slate-800 px-2 py-1 rounded">
                                                        Updated: {candleState.lastUpdate.toLocaleTimeString()}
                                                    </span>
                                                </div>
                                            )}
                                            {/* T028: Error display */}
                                            {candleState.error && !candleState.isLoading && (
                                                <div className="absolute inset-0 flex items-center justify-center bg-slate-900 z-10">
                                                    <div className="flex flex-col items-center gap-3 text-center px-4">
                                                        <div className="text-red-400 text-sm font-medium">{candleState.error}</div>
                                                        <button
                                                            onClick={candleState.refresh}
                                                            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded"
                                                        >
                                                            Retry
                                                        </button>
                                                    </div>
                                                </div>
                                            )}
                                            {/* T049: Error boundary for indicator rendering failures (polling mode) */}
                                            <ErrorBoundary fallback={
                                                <div className="absolute inset-0 flex items-center justify-center bg-slate-900 z-10">
                                                    <div className="text-center">
                                                        <div className="text-red-400 text-sm mb-2">Chart rendering failed</div>
                                                        <button
                                                            onClick={() => window.location.reload()}
                                                            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded"
                                                        >
                                                            Reload
                                                        </button>
                                                    </div>
                                                </div>
                                            }>
                                                <ChartComponent
                                                    key={`${symbol}-${chartInterval}-polling`}
                                                    symbol={symbol}
                                                    candles={candleState.candles}
                                                    width={dimensions.width}
                                                    height={mainHeight}
                                                    onTimeScaleInit={setMainTimeScale}
                                                    onCrosshairMove={handleMainCrosshairMove}
                                                    overlays={mergedOverlays}
                                                    onVisibleTimeRangeChange={handleVisibleTimeRangeChange}
                                                    showVolume={true}
                                                    showLastPrice={true}
                                                />
                                            </ErrorBoundary>
                                        </>
                                        )
                                    }}
                                </CandleDataProvider>
                            ) : (
                                /* WebSocket mode: Use existing behavior */
                                <>
                                    {/* T101: Loading state - spinner while fetching initial data */}
                                    {isInitialLoading && (
                                        <div className="absolute inset-0 flex items-center justify-center bg-slate-900 z-10">
                                            <div className="flex flex-col items-center gap-3">
                                                <div className="animate-spin rounded-full h-8 w-8 border-2 border-blue-500 border-t-transparent"></div>
                                                <span className="text-slate-400 text-sm">Loading chart data...</span>
                                            </div>
                                        </div>
                                    )}
                                    {/* T102: Error state - show error message */}
                                    {error && !isInitialLoading && (
                                        <div className="absolute inset-0 flex items-center justify-center bg-slate-900 z-10">
                                            <div className="flex flex-col items-center gap-3 text-center px-4">
                                                <div className="text-red-400 text-sm font-medium">{error}</div>
                                                <button
                                                    onClick={() => {
                                                        setError(null)
                                                        // Trigger refetch by changing symbol then changing back
                                                        const currentSymbol = symbol
                                                        setSymbol('')
                                                        setTimeout(() => setSymbol(currentSymbol), 0)
                                                    }}
                                                    className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded"
                                                >
                                                    Retry
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                    {/* T049: Error boundary for indicator rendering failures */}
                                    <ErrorBoundary fallback={
                                        <div className="absolute inset-0 flex items-center justify-center bg-slate-900 z-10">
                                            <div className="text-center">
                                                <div className="text-red-400 text-sm mb-2">Chart rendering failed</div>
                                                <button
                                                    onClick={() => window.location.reload()}
                                                    className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded"
                                                >
                                                    Reload
                                                </button>
                                            </div>
                                        </div>
                                    }>
                                        <ChartComponent
                                            key={`${symbol}-${chartInterval}`}
                                            symbol={symbol}
                                            candles={candles}
                                            width={dimensions.width}
                                            height={mainHeight}
                                            onTimeScaleInit={setMainTimeScale}
                                            onCrosshairMove={handleMainCrosshairMove}
                                            overlays={mergedOverlays}
                                            onVisibleTimeRangeChange={handleVisibleTimeRangeChange}
                                            showVolume={true}
                                            showLastPrice={true}
                                        />
                                    </ErrorBoundary>
                                </>
                            )}
                        </div>

                        {/* Dynamically render indicator panes */}
                        {effectiveVisibleOscillators.length > 0 && (
                            <div className="flex flex-col gap-0 min-h-0 w-full">
                                {effectiveVisibleOscillators.map((ind, index) => {
                                    const data = indicatorDataMap[ind.id] ?? undefined
                                    const isVisible = ind.displaySettings.visible && indicatorSettings[ind.id]?.visible !== false
                                    const isLast = index === effectiveVisibleOscillators.length - 1

                                    if (!isVisible) return null
                                    // Don't filter out indicators that don't have data yet - they might be loading

                                    const typeKey = ind.indicatorType.name.toLowerCase()
                                    const showLastValue =
                                      indicatorSettings[ind.id]?.showLastValue ??
                                      indicatorSettings[typeKey]?.showLastValue ??
                                      true

                                    return (
                                        <div
                                            key={ind.id}
                                            className="bg-slate-900 p-1 border border-t-0 border-slate-800 w-full relative shrink-0"
                                            style={{
                                                borderRadius: isLast ? '0 0 0.5rem 0.5rem' : '0',
                                                height: eachPaneHeight  // Feature 005: Explicit pixel height instead of flex-1
                                            }}
                                        >
                                            <IndicatorPane
                                                name={ind.name}
                                                displayName={ind.name}
                                                indicatorId={ind.id}
                                                style={ind.style}
                                                symbol={symbol}
                                                interval={chartInterval}
                                                width={dimensions.width}
                                                height={eachPaneHeight}
                                                onTimeScaleInit={(ts) => {
                                                    if (ts) {
                                                        indicatorTimeScalesRef.current.set(ind.id, ts)
                                                        if (mainTimeScale) {
                                                            const range = mainTimeScale.getVisibleLogicalRange()
                                                            if (range) ts.setVisibleLogicalRange(range)
                                                        }
                                                    } else {
                                                        indicatorTimeScalesRef.current.delete(ind.id)
                                                    }
                                                }}
                                                onChartInit={(chart, series) => {
                                                    indicatorChartsRef.current.set(ind.id, { chart, series });
                                                }}
                                                candles={candles}
                                                indicatorData={data}
                                                crosshairTime={crosshairTime}
                                                showLastValue={showLastValue}
                                                onSettingsClick={() => handleOscillatorSettings(ind.id)}
                                                onViewSource={() => handleOscillatorViewSource(ind.id)}
                                                onRemove={() => removeIndicator(ind.id)}
                                                onAlertCreated={async () => {
                                                    try {
                                                        const { listAlerts } = await import('./api/alerts');
                                                        const updatedAlerts = await listAlerts({ symbol });
                                                        setAlerts(updatedAlerts);
                                                    } catch (error) {
                                                        console.error('Failed to refresh alerts:', error);
                                                    }
                                                }}
                                                params={ind.indicatorType.params}
                                                alerts={alerts}
                                            />
                                        </div>
                                    )
                                })}
                            </div>
                        )}
                    </div>
            </div>
        </Layout>

        <IndicatorDialog
          open={isIndicatorsOpen}
          onOpenChange={setIsIndicatorsOpen}
          onAddOverlayInstance={(indicatorName, params) => addOverlayInstance(indicatorName, params)}
        />

        {/* T047: Indicator settings dialog for overlay indicators */}
        <IndicatorSettingsDialog
          open={isSettingsOpen}
          onOpenChange={setIsSettingsOpen}
          indicator={overlayInstances.find(i => i.id === settingsIndicatorId) || null}
          indicatorMetadata={settingsIndicatorId ? overlayInstanceDataMap[settingsIndicatorId]?.metadata : undefined}
          onApplyChanges={(instanceId, updates) => {
            updateInstance(instanceId, updates);
          }}
          onRemove={(instanceId) => {
            removeOverlayInstance(instanceId);
            setIsSettingsOpen(false);
          }}
        />

        {/* Phase 6: Oscillator settings dialog */}
        <OscillatorSettingsDialog
          open={oscillatorSettingsOpen}
          onOpenChange={setOscillatorSettingsOpen}
          indicator={indicators.find(i => i.id === oscillatorSettingsIndicatorId) || null}
          indicatorMetadata={oscillatorSettingsIndicatorId ? {
            parameters: [], // TODO: fetch from backend
            series_metadata: indicatorDataMap[oscillatorSettingsIndicatorId]?.metadata.series_metadata,
          } : undefined}
          onStyleChange={handleOscillatorApplyChanges}
          onVisibilityToggle={(indicatorId) => {
            // Use existing toggleIndicator from context
            const indicator = indicators.find(ind => ind.id === indicatorId);
            if (indicator) {
              // The toggleIndicator function exists in the context but we need to import it
              // For now, we'll use the indicatorSettings override
              setIndicatorSettings(prev => ({
                ...prev,
                [indicatorId]: {
                  ...prev[indicatorId],
                  visible: prev[indicatorId]?.visible === false ? true : false
                }
              }));
            }
          }}
          onRemove={handleOscillatorRemove}
        />

        {/* Feature 008: Source code modal for overlay indicators */}
        <SourceCodeModal
          open={sourceCodeIndicatorId !== null}
          onOpenChange={(open) => !open && setSourceCodeIndicatorId(null)}
          indicator={overlayInstances.find(i => i.id === sourceCodeIndicatorId) || null}
        />

        {/* Feature 009: Watchlist search dialog */}
        <WatchlistSearch
          open={isSearchOpen}
          onOpenChange={setIsSearchOpen}
          onSelectSymbol={handleSearchSelectSymbol}
        />
      </TooltipProvider>
    </>
  )
}

// Main App component - manages symbol state and wraps with IndicatorProvider
function App() {
  const [symbol, setSymbol] = useState('IBM')

  return (
    <IndicatorProvider symbol={symbol}>
      <AppContent symbol={symbol} setSymbol={setSymbol} />
    </IndicatorProvider>
  )
}

export default App